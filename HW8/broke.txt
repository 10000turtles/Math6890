// 2 // Solvetheheatequationinone-dimension 3 // 4 5 #include<stdio.h> 6 #include<math.h> 7 #include<float.h> 8 #include<assert.h> 9 10 //defineanewtype"Real"whichisequivalenttoa"double" 11 typedefdoubleReal; 12 13 #include<string> 14 usingstd::string; 15 usingstd::max; 16 17 #include<ctime> 18 //-------------------------------------------- 19 //Returnthecurrentwall-clocktimeinseconds 20 //-------------------------------------------- 21 inlinedoublegetCPU() 22 { 23 return(1.0*std::clock())/CLOCKS_PER_SEC; 24 } 25 26 27 //-------------------------------------------------------------------------------------- 28 //Functiontosaveavectortoamatlabfile. 29 // matlabFile (input):savevector tothisfile 30 // u_p (input):arrayofvectorvalues 31 // name (input):nameforarray 32 // (nd1a:nd1b)(input):arraydimensions 33 //-------------------------------------------------------------------------------------- 34 intwriteMatlabVector(FILE*matlabFile,Real*u_p,constchar*name,intnd1a,intnd1b) 35 { 36 #defineu(i)u_p[i-nd1a] 37 38 constint numPerLine=8; //numberofentriesperline 39 //Savethevectoras: 40 // name =[numnumnumnumnum... 41 // numnumnumnumnum]; 42 fprintf(matlabFile,"%s=[",name); 43 for(inti=nd1a;i<=nd1b;i++) 44 { 45 fprintf(matlabFile,"%20.15e",u(i)); 46 if((i-nd1a)%numPerLine==numPerLine-1) 47 fprintf(matlabFile,"...\n"); // continuationline 48 } 49 fprintf(matlabFile,"];\n"); 50 51 return0; 52 } 53 54 intmain(intargc,char*argv[]) 55 { 56 printf("Usage:heat1d[Nx][matlabFileName.m]\n" 57 " Nx=numberofgridcells.\n" 58 " matlabFileName.m:save resultstothisfile.\n"); 59 60 #defineTRIG_DD1 61 #defineTRIG_NN2 62 #definePOLY_DD3 63 #definePOLY_NN4 64 //=====Choosethesolutionhereor compilewith-DSOLUTION=[1|2|3|4]===== 65 #ifndefSOLUTION 66 #defineSOLUTIONTRIG_DD 67 //#defineSOLUTIONTRIG_NN 68 //#defineSOLUTIONPOLY_DD 69 //#defineSOLUTIONPOLY_NN 70 #endif 71 72 constRealpi=M_PI; 73 74 intdebug=0;//setto1fordebuginfo 75 Realxa=0.,xb=1.; 76 Realkappa=.1; 77 RealtFinal=.2; 78 Realcfl=.9; //time-stepsafetyfactor 79 80 intNx=10; //default 81 stringmatlabFileName="heat1d.m"; 82 83 if(argc>=2)//readanycommandline arguments 84 { 85 Nx=atoi(argv[1]); 86 printf("SettingNx=%d\n",Nx); 87 if(argc>=3) 88 { 89 matlabFileName=argv[2]; 90 printf("SettingmatlabFileName=[%s]\n",matlabFileName.c_str()); 91 } 92 } 93 94 //=============Gridandindexing============== 95 // xa xb 96 // G---X---+---+---+---+--...---+---X---G 97 // 0 1 2 Nx 98 // n1a n1b 99 // nd1a nd1b 100 //Cindex: 0 1 2 3... 101 102 Realdx= (xb-xa)/Nx; 103 constint numGhost=1; 104 constint n1a=0; 105 constint n1b=Nx; 106 constint nd1a=n1a-numGhost; 107 constint nd1b=n1b+numGhost; 108 constint nd1=nd1b-nd1a+1;//totalnumberofgridpoints; 109 110 //Create anarrayofgridpoints: 111 Real*x_p =newReal[nd1]; 112 #definex(i)x_p[i-nd1a] 113 114 for(inti=nd1a;i<=nd1b;i++) 115 x(i)=xa+(i-n1a)*dx; 116 117 if(debug>1) 118 { 119 for(inti=nd1a;i<=nd1b;i++) 120 printf("x(%2d)=%12.4e\n",i,x(i)); 121 } 122 123 constint dirichlet=1,neumann=2; 124 constint numberOfDimensions=1; 125 int*boundaryCondition_p=newint[2*numberOfDimensions]; 126 #defineboundaryCondition(side,axis) boundaryCondition_p[(side)+2*(axis)] 127 128 129 constRealkx=3.; 130 constRealkxPi=kx*pi; 131 constRealkappaPiSq=kappa*kxPi*kxPi; 132 133 #ifSOLUTION==TRIG_DD 134 //True solutionfordirichletBC’s 135 boundaryCondition(0,0)=dirichlet; 136 boundaryCondition(1,0)=dirichlet; 137 138 constcharsolutionName[]="trueDD"; 139 140 #define UTRUE(x,t)sin(kxPi*(x))*exp(-kappaPiSq*(t)) 141 #define UTRUEX(x,t)kxPi*cos(kxPi*(x))*exp(-kappaPiSq*(t)) 142 #define FORCE(x,t)(0.) 143 144 #elifSOLUTION==TRIG_NN 145 146 //True solutionforNeumannBC’s 147 boundaryCondition(0,0)=neumann; 148 boundaryCondition(1,0)=neumann; 149 constcharsolutionName[]="trueNN"; 150 151 #define UTRUE(x,t)cos(kxPi*(x))*exp(-kappaPiSq*(t)) 152 #define UTRUEX(x,t)-kxPi*sin(kxPi*(x))*exp(-kappaPiSq*(t)) 153 #define FORCE(x,t)(0.) 154 155 #elif(SOLUTION==POLY_DD)||(SOLUTION==POLY_NN) 156 157 //polynomialmanufacturedsolution 158 #ifSOLUTION==POLY_DD 159 constcharsolutionName[]="polyDD"; 160 boundaryCondition(0,0)=dirichlet; 161 boundaryCondition(1,0)=dirichlet; 162 #else 163 constcharsolutionName[]="polyNN"; 164 boundaryCondition(0,0)=neumann; 165 boundaryCondition(1,0)=neumann; 166 #endif 167 168 constRealb0=1.,b1=.5,b2=.25; 169 constReala0=1.,a1=.3; 170 #define UTRUE(x,t)(b0+(x)*(b1+(x)*b2 ))*(a0+(t)*(a1)) 171 #define UTRUEX(x,t)(b1+2.*(x)*b2 )*(a0+(t)*(a1)) 172 #define UTRUET(x,t)(b0+(x)*(b1+(x)*b2 ))*(a1) 173 #define UTRUEXX(x,t)(2.*b2)*(a0+(t)*(a1)) 174 175 //force=u_t-kappa*u.xx 176 #define FORCE(x,t)(UTRUET(x,t)-kappa*UTRUEXX(x,t)) 177 178 #else 179 printf("ERROR:unknownsolution"); 180 abort(); 181 #endif 182 183 184 Real*u_p[2]; //twoarrayswillbeusedforcurrentandnewtimes 185 u_p[0]=newReal[nd1]; 186 u_p[1]=newReal[nd1]; 187 188 //Macros todefinefortranlikearrays 189 #defineuc(i)u_p[cur][i-nd1a] 190 #defineun(i)u_p[next][i-nd1a] 191 192 //initialconditions 193 Realt=0.; 194 intcur= 0;//"current"solution,indexintou_p[] 195 for(inti=nd1a;i<=nd1b;i++) 196 uc(i)=UTRUE(x(i),t); 197 198 if(debug>0) 199 { 200 printf("Afterinitialconditions\nu=["); 201 for(inti=nd1a;i<=nd1b;i++) 202 printf("%10.4e,",uc(i)); 203 printf("]\n"); 204 } 205 206 //Time-steprestrictioniskappa*dt/dx^2<.5 207 constRealdx2 =dx*dx; 208 Realdt =cfl*.5*dx2/kappa; //dt,adjustedbelow 209 constint numSteps=ceil(tFinal/dt); 210 dt =tFinal/numSteps; //adjustdttoreachthefinaltime 211 constRealrx =kappa*dt/dx2; 212 213 printf("-------------------Solvetheheatequationin1Dsolution=%s---------------------\n", 214 solutionName); 215 printf(" numGhost=%d,n1a=%d,n1b=%d, nd1a=%d,nd1b=%d\n",numGhost,n1a,n1b,nd1a,nd1b); 216 printf(" numSteps=%d,Nx=%d,kappa=%g,tFinal=%g,boundaryCondition(0,0)=%d,boundaryCondition (1,0)=%d\n", 217 numSteps,Nx,kappa,tFinal,boundaryCondition(0,0),boundaryCondition(1,0)); 218 219 //----------TIME-STEPPINGLOOP-------- 220 Realcpu0 =getCPU(); 221 for(intn=0;n<numSteps;n++) 222 { 223 t=n*dt; //currenttime 224 225 constintcur= n %2; // currenttimelevel 226 constintnext=(n+1)%2; //nexttimelevel 227 228 //---updatetheinteriorpoints--- 229 for(inti=n1a;i<=n1b;i++) 230 { 231 un(i)=uc(i)+rx*(uc(i+1)-2.*uc(i)+uc(i-1)) +dt*FORCE(x(i),t); 232 } 233 234 //----boundaryconditions--- 235 for(intside=0;side<=1;side++) 236 { 237 constinti=side==0?n1a:n1b;//boundaryindex 238 constintis=1-2*side; //is=1onleft,-1onright 239 if(boundaryCondition(side,0)==dirichlet ) 240 { 241 un(i) =UTRUE(x(i),t+dt); 242 un(i-is)=3.*un(i)-3.*un(i+is)+un(i+2*is); //extrapolateghost 243 } 244 else 245 { 246 //NeumannBC 247 un(i-is)=un(i+is)-2.*is*dx*UTRUEX(x(i),t+dt); 248 } 249 } 250 251 if(debug>1) 252 { 253 printf("step%d:AfterupdateinteriorandrealBCs\nu=[",n+1); 254 for(inti=nd1a;i<=nd1b;i++) 255 printf("%12.4e,",un(i)); 256 printf("]\n"); 257 } 258 259 if(debug>0) 260 { 261 //computetheerror 262 RealmaxErr=0.; 263 for(inti=nd1a;i<=nd1b;i++) 264 { 265 Real err=fabs(un(i)-UTRUE(x(i),t+dt)); 266 maxErr=max(maxErr,err); 267 } 268 printf("step=%d,t=%9.3e,maxErr=%9.2e\n",n+1,t+dt,maxErr); 269 } 270 271 }//endtime-steppingloop 272 273 RealcpuTimeStep=getCPU()-cpu0; 274 275 //----checktheerror---- 276 t+=dt;//tFinal; 277 if(fabs(t-tFinal)>1e-3*dt/tFinal) 278 { 279 printf("ERROR:AFTERTIME_STEPPING:t=%16.8eISNOTEQUALtotFinal=%16.8e\n",t,tFinal); 280 } 281 282 Real*error_p=newReal[nd1]; 283 #defineerror(i)error_p[i-nd1a] 284 285 cur=numSteps%2; 286 RealmaxErr=0.; 287 for(inti=nd1a;i<=nd1b;i++) 288 { 289 error(i)=uc(i)-UTRUE(x(i),t); 290 maxErr=max(maxErr,abs(error(i))); 291 } 292 293 printf("numSteps=%4d,Nx=%3d,maxErr=%9.2e,cpu=%9.2e(s)\n",numSteps,Nx,maxErr,cpuTimeStep); 294 295 //---Writeafileforplottinginmatlab-- 296 FILE*matlabFile=fopen(matlabFileName.c_str(),"w"); 297 fprintf(matlabFile,"%%Filewrittenby heat1d.C\n"); 298 fprintf(matlabFile,"xa=%g;xb=%g;kappa=%g;t=%g;maxErr=%10.3e;cpuTimeStep=%10.3e;\n",xa,xb, kappa,tFinal,maxErr,cpuTimeStep); 299 fprintf(matlabFile,"Nx=%d;dx=%14.6e;numGhost=%d;n1a=%d;n1b=%d;nd1a=%d;nd1b=%d;\n",Nx,dx, numGhost,n1a,n1b,nd1a,nd1b); 300 fprintf(matlabFile,"solutionName=\’%s\’;\n",solutionName); 301 302 writeMatlabVector(matlabFile,x_p, "x", nd1a,nd1b); 303 writeMatlabVector(matlabFile,u_p[cur],"u", nd1a,nd1b); 304 writeMatlabVector(matlabFile,error_p, "err",nd1a,nd1b); 305 306 fclose(matlabFile); 307 printf("Wrotefile%s\n\n",matlabFileName.c_str()); 308 309 delete[] u_p[0]; 310 delete[] u_p[1]; 311 delete[] x_p; 312 delete[] error_p; 313 delete[] boundaryCondition_p; 314 315 return0; 316 }