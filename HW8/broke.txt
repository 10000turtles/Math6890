#ifndefGET_LOCAL_INDEX_BOUNDS_H 2 #defineGET_LOCAL_INDEX_BOUNDS_H 3 4 //======================================================================= 5 //Distributeanindexdimensionacrossnpxprocessors: 6 // rank (input):rankofprocess,0<=rank<npx 7 // npx (input):distributeacrossthismanyprocessors 8 // nx (input):totalnumberofgridcellsonglobalgrid 9 // nx_l,n1a_l,n1b_l(output):localvalues 10 // 11 //Note:nx+1=totalgridpointsacrossallprocessors 12 //======================================================================== 13 intgetLocalIndexBounds(constintrank,constintnpx,constintnx, 14 int&nx_l,int&n1a_l,int&n1b_l) 15 { 16 //----Example:distributegridpoints----- 17 //Global: 18 // X--X--X--X--X--X--X--X--X--X--X 19 // 0 1 2 3 4 5 6 7 8 9 10 nx=10 20 // n1a n1b 21 //Local:(rank=0,np=2) 22 // X--X--X--X--X--X 23 // 0 1 2 3 4 5 nx_l=5 24 // n1a_l n1b_l 25 //Local:(rank=1,np=2) 26 // X--X--X--X--X 27 // 6 7 8 9 10 nx_l=4 28 // n1a_l n1b_l 29 // 30 nx_l=(nx+1)/npx-1; //nx_l+1=(nx_1+1)/np 31 n1a_l=(nx_l+1)*rank; //localstartingindex 32 33 //Theremaybeextrapointsif(nx+1)isnotamultipleofnp 34 intextra=nx+1-npx*(nx_l+1); 35 if(rank<extra) 36 {//addoneextrapointtoprocâ€™sontheleftside 37 nx_l+=1; 38 n1a_l+=rank; 39 } 40 else 41 { 42 n1a_l+=extra; 43 } 44 n1b_l=n1a_l+nx_l; //localendindex 45 46 return0; 47 } 48 49 #endif