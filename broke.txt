//============================================================================== 2 // Solvethe2DheatequationusinganADIscheme 3 // 4 //============================================================================== 5 6 #include"A++.h" 7 8 typedefdoubleReal; 9 typedefdoubleSerialArrayRealArray; 10 typedefintSerialArrayIntegerArray; 11 12 #include<float.h> 13 #include<limits.h> 14 #defineREAL_EPSILONDBL_EPSILON 15 #defineREAL_MINDBL_MIN 16 17 //getCPU():Returnthecurrentwall-clocktimeinseconds 18 #include"getCPU.h" 19 20 //includecommandstoparsecommandlinearguments 21 #include"parseCommand.h" 22 23 //Tridiagonalfactorandsolve: 24 #include"tridiagonal.h" 25 26 //functiontowriteanarraytoamatlabreabablefile: 27 #include"writeMatlabArray.h" 28 29 //definemacrosforarrayreferences 30 #defineUN(i1,i2)un_p[(i1)+Ngx*(i2)] 31 #defineU(i1,i2)u_p[(i1)+Ngx*(i2)] 32 33 #defineAX(i,j)Ax_p[(i)+3*(j)] 34 #defineAY(i,j)Ay_p[(i)+3*(j)] 35 #defineRHSX(i1)rhsx_p[(i1)] 36 #defineRHSY(i1)rhsy_p[(i1)] 37 38 #defineRHS(i)rhs_p[(i)] 39 40 41 //===================================================================================== 42 //FormthetridiagonalmatrixfortheAFSscheme 43 //===================================================================================== 44 intformTridiagonalMatrix(RealArray&Ax,constRealkappa,constRealdt,constRealdx) 45 { 46 constintn1a=Ax.getBase(1),n1b=Ax.getBound(1); 47 48 for(inti1=n1a+1;i1<=n1b-1;i1++) 49 { 50 Ax(0,i1)=-(.5*kappa*dt)*(1./(dx*dx));//lowerdiagonal 51 Ax(1,i1)=1.-(.5*kappa*dt)*(-2.*(1./(dx*dx)));//diagonal 52 Ax(2,i1)=-(.5*kappa*dt)*(1./(dx*dx));//upperdiagonal 53 } 54 Ax(0,n1a)=0.;Ax(1,n1a)=1.;Ax(2,n1a)=0.;//DirichletBC 55 Ax(0,n1b)=0.;Ax(1,n1b)=1.;Ax(2,n1b)=0.;//DirichletBC 56 57 return0; 58 } 59 60 61 int 62 main(intargc,char*argv[]) 63 { 64 printf("Usage:heatADI-nx=<i>-tFinal=<f>-saveMatlab=[0|1|2]-matlabFileName=<s>\n"); 65 66 constRealpi=M_PI; //4.*atan2(1.,1.); 67 68 ios::sync_with_stdio(); //SynchronizeC++andCI/Osubsystems 69 Index::setBoundsCheck(on); // TurnonA++arrayboundschecking 70 71 intdebug=0; //setto1fordebugging 72 intplot=0; //set11forplotting 73 Realkappa=.05; //coefficientofdiffusion 74 Realxa=0.,xb=1.,ya=0.,yb=1.; //spaceintervalinterval 75 RealtFinal=.5; //finaltime 76 77 intnx=100,ny=nx; 78 79 intsaveMatlab=0;//1=saveamatlabfile,2=savesolutiontoo 80 stringmatlabFileName="heatADI.m"; 81 82 constintdirichlet=1,neumann=2; 83 constintnumberOfDimensions=2; 84 IntegerArrayboundaryCondition(2,numberOfDimensions); 85 boundaryCondition(0,0)=dirichlet;//left 86 boundaryCondition(1,0)=dirichlet;//right 87 boundaryCondition(0,1)=dirichlet;//bottom 88 boundaryCondition(1,1)=dirichlet;//top 89 90 stringline; 91 for(inti=1;i<argc;i++) 92 { 93 line=argv[i]; 94 printf("Input:argv[%d]=[%s]\n",i,line.c_str()); 95 96 if(parseCommand(line,"-nx=",nx)){ny=nx;} 97 elseif(parseCommand(line,"-debug=",debug)){} 98 elseif(parseCommand(line,"-tFinal=",tFinal)){} 99 elseif(parseCommand(line,"-saveMatlab=",saveMatlab)){} 100 elseif(parseCommand(line,"-matlabFileName=",matlabFileName)){} 101 102 } 103 104 //exactsolutionfunction: 105 constRealkx=2.,ky=3; 106 constRealkxp=kx*pi; 107 constRealkyp=ky*pi; 108 #defineUTRUE(x,y,t)sin(kxp*(x))*sin(kyp*(y))*exp(-kappa*(kxp*kxp+kyp*kyp)*(t)) 109 110 //---Setupthegrid-- 111 // xa xb 112 // +--+--+--+--....--+--+ 113 // 0 1 2 nx 114 115 //NoghostneededforDirichletBCs 116 constintnumGhost=0; 117 118 constintn1a=numGhost; constintn2a=numGhost; 119 constintn1b=n1a+nx; constintn2b=n2a+ny; 120 constintnd1a=n1a-numGhost; constintnd2a=n2a-numGhost; 121 constintnd1b=n1b+numGhost; constintnd2b=n2b+numGhost; 122 constintnd1=nd1b-nd1a+1; constintnd2=nd2b-nd2a+1; 123 124 IntegerArraygridIndexRange(2,numberOfDimensions); 125 IntegerArraydimension(2,numberOfDimensions); 126 gridIndexRange(0,0)=n1a;gridIndexRange(1,0)=n1b; 127 gridIndexRange(0,1)=n2a;gridIndexRange(1,1)=n2b; 128 dimension(0,0)=nd1a;dimension(1,0)=nd1b; 129 dimension(0,1)=nd2a;dimension(1,1)=nd2b; 130 131 //--formthe2Dgridpoints-- 132 Realdx[2]; 133 dx[0]=(xb-xa)/nx; 134 dx[1]=(yb-ya)/ny; 135 136 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 137 RealArrayx(Rx,Ry,2); 138 inti1,i2; 139 for(i2=nd2a;i2<=nd2b;i2++) 140 for(i1=nd1a;i1<=nd1b;i1++) 141 { 142 x(i1,i2,0)=xa+(i1-n1a)*dx[0]; 143 x(i1,i2,1)=ya+(i2-n2a)*dx[1]; 144 } 145 146 //allocatespaceforthesolution 147 RealArrayun(Rx,Ry); //holdsU_i^n 148 RealArrayu(Rx,Ry); //tempspace 149 150 Realdt=min(dx[0],dx[1]); //timestep(adjustedbelow) 151 intNt=ceil(tFinal/dt); //numberoftime-steps 152 dt=tFinal/Nt; //adjustdttoreachtFinalexactly 153 154 printf("-----2DHeatEquation:ADIscheme------\n"); 155 printf(" saveMatlab=%d,matlabFileName=%s\n",saveMatlab,matlabFileName.c_str()); 156 printf(" kappa=%.3g,nx=%d,ny=%d,tFinal=%6.2f,kx=%g,ky=%g\n",kappa,nx,ny,tFinal,kx,ky); 157 158 159 Realt=0.,th,tn; 160 IndexI1=Rx,I2=Ry;//allpoints 161 162 un(I1,I2)=UTRUE(x(I1,I2,0),x(I1,I2,1),t); //initialconditions 163 164 //-----Formtheimplicitmatrices----- 165 //Note:thematrixissymmetricsowecouldjuststore2entries(*BUT*factorizationneeds extrastorageanyway) 166 //Keepallthreeincaseweaddadvection 167 168 constintNgx=nd1,Ngy=nd2; //sizeoftridiagonalsystems 169 RealArrayAx(3,Ngx),Ay(3,Ngy); 170 RealArrayrhsx(Ngx),rhsy(Ngy); 171 172 Real*rhsx_p=rhsx.getDataPointer(); 173 Real*rhsy_p=rhsy.getDataPointer(); 174 175 formTridiagonalMatrix(Ax,kappa,dt,dx[0]); 176 factorTridiagonalMatrix(Ax); 177 178 formTridiagonalMatrix(Ay,kappa,dt,dx[1]); 179 factorTridiagonalMatrix(Ay); 180 181 constRealrxBy2=.5*kappa*dt/(dx[0]*dx[0]); 182 constRealryBy2=.5*kappa*dt/(dx[1]*dx[1]); 183 184 //getpointersforarrayreferencemacros: 185 Real*un_p=un.getDataPointer(); 186 Real*u_p=u.getDataPointer(); 187 188 // ============Starttime-steppingloop========== 189 RealcpuTriSolves=0;//cpufortridiagonalsolves 190 Realcpu0=getCPU(); 191 for(intn=0;n<Nt;n++)//time-steploop 192 { 193 t=n*dt; //currenttime 194 th=t+.5*dt; //halftime 195 tn=t+dt; //newtime 196 197 // StageI: 198 // [I+(.5*kappa*dt)*(D+xD-x)]U^*_ij=[I+(.5*kappa*dt)*(D+yD-y)]U^n_ij 199 // Note:saveU^*inU 200 for(i2=n2a+1;i2<=n2b-1;i2++) 201 for(i1=n1a+1;i1<=n1b-1;i1++) 202 { 203 U(i1,i2)=UN(i1,i2)+ryBy2*(UN(i1,i2+1)-2.*UN(i1,i2)+UN(i1,i2-1)); //rhs 204 } 205 206 // Boundaryconditions W^*=g(x,t+dt/2) 207 for(intside=0;side<=1;side++) 208 { 209 i1=side==0?n1a:n1b; 210 for(i2=n2a;i2<=n2b;i2++) 211 U(i1,i2)=UTRUE(x(i1,i2,0),x(i1,i2,1),th); //left/right 212 i2=side==0?n2a:n2b; 213 for(i1=n2a;i1<=n1b;i1++) 214 U(i1,i2)=UTRUE(x(i1,i2,0),x(i1,i2,1),th); //bottom/top 215 } 216 217 //---tridiagonalsolvesinx-direction-- 218 Realcpu1=getCPU(); 219 for(i2=n2a+1;i2<=n2b-1;i2++)//excludetopanbottomboundaries 220 { 221 for(i1=n1a;i1<=n1b;i1++) 222 RHSX(i1)=U(i1,i2); 223 224 solveTridiagonal(Ax,rhsx); 225 226 for(i1=n1a;i1<=n1b;i1++) 227 U(i1,i2)=RHSX(i1); //saveU^*inU 228 } 229 cpuTriSolves+=getCPU()-cpu1; 230 231 //-----StageII 232 // [I+(.5*kappa*dt)*(D+yD-y)]U^{n+1}_ij=[I+(.5*kappa*dt)*(D+xD-x)]U^*_ij 233 for(i2=n2a+1;i2<=n2b-1;i2++) 234 for(i1=n1a+1;i1<=n1b-1;i1++) 235 { 236 UN(i1,i2)=U(i1,i2)+rxBy2*(U(i1+1,i2)-2.*U(i1,i2)+U(i1-1,i2)); //rhs 237 } 238 239 // Boundaryconditions W^*=g(x,t+dt/2) 240 for(intside=0;side<=1;side++) 241 { 242 i1=side==0?n1a:n1b; 243 for(i2=n2a;i2<=n2b;i2++) 244 UN(i1,i2)=UTRUE(x(i1,i2,0),x(i1,i2,1),tn); //left/right 245 i2=side==0?n2a:n2b; 246 for(i1=n2a;i1<=n1b;i1++) 247 UN(i1,i2)=UTRUE(x(i1,i2,0),x(i1,i2,1),tn); //bottom/top 248 } 249 250 //---tridiagonalsolvesiny-direction-- 251 cpu1=getCPU(); 252 for(i1=n1a+1;i1<=n1b-1;i1++)//excludeleftandrightboundaries 253 { 254 for(i2=n2a;i2<=n2b;i2++) 255 RHSY(i2)=UN(i1,i2); 256 257 solveTridiagonal(Ay,rhsy); 258 259 for(i2=n2a;i2<=n2b;i2++) 260 UN(i1,i2)=RHSY(i2); 261 } 262 cpuTriSolves+=getCPU()-cpu1; 263 264 } 265 // ============ENDtime-steppingloop========== 266 RealcpuTimeStep=getCPU()-cpu0; 267 268 t=tn;//lasttime 269 if(fabs(t-tFinal)>1.e-12*tFinal) 270 { 271 printf("...doneERROR:t=%12.4e,tFinal=%12.4e,t-tFinal=%9.2e\n",t,tFinal,t-tFinal); 272 } 273 274 //---computeerrors-- 275 RealArrayerr(Ngx,Ngy); 276 277 RealmaxErr=0.,maxNorm=0.; 278 for(i2=n2a;i2<=n2b;i2++) 279 for(i1=n1a;i1<=n1b;i1++) 280 { 281 err(i1,i2)=fabs(un(i1,i2)-UTRUE(x(i1,i2,0),x(i1,i2,1),tFinal)); 282 maxErr=max(err(i1,i2),maxErr); 283 maxNorm=max(un(i1,i2),maxNorm); 284 } 285 maxErr/=max(maxNorm,REAL_MIN); //relativeerror 286 287 printf("ADI:nx=%3dny=%3dNt=%3d,maxNorm=%8.2emaxRelErr=%8.2ecpu(s):total=%9.2e,triSolves =%9.2e\n", 288 nx,ny,Nt,maxNorm,maxErr,cpuTimeStep,cpuTriSolves); 289 290 //---OPTIONALLYwriteamatlabfileforplottinginmatlab-- 291 if(saveMatlab) 292 { 293 FILE*matlabFile=fopen(matlabFileName.c_str(),"w"); 294 fprintf(matlabFile,"%%FilewrittenbyheatADI.C\n"); 295 fprintf(matlabFile,"xa=%g;xb=%g;ya=%g;yb=%g;kappa=%g;t=%g;maxErr=%10.3e;cpuTimeStep =%10.3e;cpuTriSolves=%10.3e;\n", 296 xa,xb,ya,yb,kappa,tFinal,maxErr,cpuTimeStep,cpuTriSolves); 297 298 fprintf(matlabFile,"n1a=%d;n1b=%d;nd1a=%d;nd1b=%d;\n",n1a,n1b,nd1a,nd1b); 299 fprintf(matlabFile,"n2a=%d;n2b=%d;nd2a=%d;nd2b=%d;\n",n2a,n2b,nd2a,nd2b); 300 fprintf(matlabFile,"dx(1)=%14.6e;dx(2)=%14.6e;numGhost=%d;\n",dx[0],dx[1],numGhost); 301 302 if(saveMatlab>1) 303 { 304 writeMatlabArray(matlabFile,x, "x",2,dimension); 305 writeMatlabArray(matlabFile,un, "u",1,dimension); 306 writeMatlabArray(matlabFile,err,"err",1,dimension); 307 } 308 fclose(matlabFile); 309 printf("Wrotefile[%s]\n",matlabFileName.c_str()); 310 } 311 312 return0; 313 }