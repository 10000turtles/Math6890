//===================================================================== 2 // 3 // POISSONEQUATIONINTWODIMENSIONS 4 //-Delta(u)=f 5 // 6 // SolvewithA++arrays 7 // 8 //===================================================================== 9 #include"A++.h" 10 11 typedefdoubleReal; 12 typedefdoubleSerialArrayRealArray; 13 typedefintSerialArrayIntegerArray; 14 15 //includecommandstpparsecommandlinearguments 16 #include"parseCommand.h" 17 18 //getCPU():Returnthecurrentwall-clocktimeinseconds 19 #include"getCPU.h" 20 21 //enumforBCâ€™s 22 enumBoundaryConditionsEnum 23 { 24 periodic=-1, 25 dirichlet=1, 26 neumann=2 27 }; 28 29 //storeparametersinthisclass 30 classPoissonParameters 31 { 32 public: 33 Realdx[2]; 34 IntegerArraygridIndexRange; 35 IntegerArraydimension; 36 IntegerArrayboundaryCondition; 37 RealArrayx; 38 Realtol; 39 RealArrayuTrue; 40 intmaxIterations; 41 intdebug; 42 intintervalToCheckResidual; 43 }; 44 45 46 //----------------------------------------------------------------------- 47 //Returnthemax-normresidual 48 //----------------------------------------------------------------------- 49 RealgetMaxResidual(RealArray&u,RealArray&f,PoissonParameters&par) 50 { 51 constIntegerArray&gridIndexRange=par.gridIndexRange; 52 constReal(&dx)[]=par.dx; //Note:referencetoanarray 53 54 constRealdxSq=dx[0]*dx[0]; 55 constRealdySq=dx[1]*dx[1]; 56 57 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 58 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 59 60 RealmaxRes=0.; 61 for(inti2=n2a+1;i2<=n2b-1;i2++) 62 for(inti1=n1a+1;i1<=n1b-1;i1++) 63 { 64 Realres=f(i1,i2)+((u(i1+1,i2)-2.*u(i1,i2)+u(i1-1,i2))/dxSq 65 +(u(i1,i2+1)-2.*u(i1,i2)+u(i1,i2-1))/dySq); 66 maxRes=max(maxRes,res); 67 } 68 69 returnmaxRes; 70 } 71 72 73 //---------------------------------------------------------------------- 74 //Returnthemax-normerror 75 //---------------------------------------------------------------------- 76 RealgetMaxError(RealArray&u,RealArray&err,PoissonParameters&par) 77 { 78 constIntegerArray&gridIndexRange=par.gridIndexRange; 79 constIntegerArray&dimension=par.dimension; 80 constIntegerArray&boundaryCondition=par.boundaryCondition; 81 constRealArray&x=par.x; 82 constReal&tol=par.tol; 83 constRealArray&uTrue=par.uTrue; 84 constReal(&dx)[]=par.dx; //Note:referencetoanarray 85 constint&maxIterations=par.maxIterations; 86 constint&debug=par.debug; 87 88 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 89 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 90 91 RealmaxErr=0.; 92 for(inti2=n2a;i2<=n2b;i2++) 93 for(inti1=n1a;i1<=n1b;i1++) 94 { 95 Realxi=x(i1,i2,0); 96 Realyi=x(i1,i2,1); 97 err(i1,i2)=fabs(u(i1,i2)-uTrue(i1,i2)); 98 maxErr=max(err(i1,i2),maxErr); 99 } 100 101 if(n1b-n1a+1<=10) 102 { 103 u.display("u"); 104 err.display("err"); 105 } 106 107 returnmaxErr; 108 } 109 110 111 #defineF(i1,i2)f_p[(i1)+nd1*(i2)] 112 #defineU(i1,i2)u_p[(i1)+nd1*(i2)] 113 #defineUN(i1,i2)un_p[(i1)+nd1*(i2)] 114 115 //-------------------------------------------- 116 //Jacobiiteration 117 //-------------------------------------------- 118 intjacobiIteration(RealArray&u,RealArray&f,PoissonParameters&par) 119 { 120 constIntegerArray&gridIndexRange=par.gridIndexRange; 121 constIntegerArray&dimension=par.dimension; 122 constIntegerArray&boundaryCondition=par.boundaryCondition; 123 constRealArray&x=par.x; 124 constReal&tol=par.tol; 125 constRealArray&uTrue=par.uTrue; 126 constReal(&dx)[]=par.dx; //Note:referencetoanarray 127 constint&maxIterations=par.maxIterations; 128 constint&debug=par.debug; 129 constint&intervalToCheckResidual=par.intervalToCheckResidual; 130 131 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 132 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 133 constintnd1a=dimension(0,0),nd1b=dimension(1,0); 134 constintnd2a=dimension(0,1),nd2b=dimension(1,1); 135 constintnd1=nd1b-nd1a+1; 136 137 constRealpi=M_PI; 138 139 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 140 141 doubleArrayua[2]; 142 ua[0].redim(Rx,Ry);ua[0]=0.; 143 ua[1].redim(Rx,Ry);ua[1]=0.; 144 145 intcurrent=0; 146 ua[current]=u;//initialguess 147 148 intn; 149 Realh=dx[0]; //assumedx=dy 150 assert(dx[0]==dx[1]); 151 Realomega=1.; 152 153 //Realres0=getMaxResidual(ua[current],f,h); 154 Realres0=getMaxResidual(ua[current],f,par); 155 RealmaxRes=res0,maxResOld=res0; 156 RealCR=1.; 157 158 constReal*f_p=f.getDataPointer(); 159 160 Realcpu1=getCPU(); 161 for(n=0;n<maxIterations;n++) 162 { 163 constintnext=(current+1)%2; 164 doubleArray&u=ua[current]; 165 doubleArray&un=ua[next]; 166 167 constReal*u_p=u.getDataPointer(); 168 Real*un_p=un.getDataPointer(); 169 170 //omega-JacobiIteration 171 for(inti2=n2a+1;i2<=n2b-1;i2++) 172 for(inti1=n1a+1;i1<=n1b-1;i1++) 173 { 174 Realz=.25*(h*h*F(i1,i2)+U(i1+1,i2)+U(i1-1,i2)+U(i1,i2+1)+U(i1,i2-1)); 175 UN(i1,i2)=U(i1,i2)+omega*(z-U(i1,i2)); 176 } 177 178 current=next; 179 180 if((n%intervalToCheckResidual)==0||n==(maxIterations-1)) 181 { 182 //checkforconvergence 183 maxRes=getMaxResidual(u,f,par); 184 CR=pow((maxRes/maxResOld),1./intervalToCheckResidual); 185 maxResOld=maxRes; 186 187 if(false) 188 printf("n=%6d,maxRes=%9.3e\n",n,maxRes); 189 190 if(maxRes<tol) 191 break; 192 } 193 194 } 195 Realcpu=getCPU()-cpu1; 196 197 constintnumIterations=n; 198 //printf("numIterations=%d,nx=%d,ny=%d,cputime=%9.2e(s)\n",numIterations,nx,ny,cpu); 199 if(maxRes<tol) 200 { 201 //printf("CONVERGENCE:maxRes=%8.2e<tol=%9.2e.\n",maxRes,tol); 202 } 203 else 204 printf("Jacobi:ERROR:maxRes=%8.2e>tol=%9.2e:NOCONVERGENCE\n",maxRes,tol); 205 206 207 //---computeerrors-- 208 u=ua[current]; 209 RealArrayerr(Rx,Ry); 210 211 RealmaxErr=getMaxError(u,err,par); 212 maxRes=getMaxResidual(u,f,par); 213 214 //Averageconvergencerate: 215 RealaveCR=pow((maxRes/res0),1./max(1,numIterations)); 216 //Asymptoticconvergencerate: 217 RealACR=fabs(1.-omega*(1.-cos(pi*h))); 218 printf("Jac:omega=%4.2fIts=%6dres=%8.2eerr=%8.2eCR=%7.5faveCR=%7.5fACR=%7.5fcpu=%7.1es cpu/it=%7.1es\n", 219 omega,numIterations,maxRes,maxErr,CR,aveCR,ACR,cpu,cpu/numIterations); 220 221 returnnumIterations; 222 } 223 224 //-------------------------------------------- 225 //Gauss-SeidelorSOR 226 //-------------------------------------------- 227 intgaussSeidelIteration(RealArray&u,RealArray&f,PoissonParameters&par) 228 { 229 constIntegerArray&gridIndexRange=par.gridIndexRange; 230 constIntegerArray&dimension=par.dimension; 231 constIntegerArray&boundaryCondition=par.boundaryCondition; 232 constRealArray&x=par.x; 233 constReal&tol=par.tol; 234 constRealArray&uTrue=par.uTrue; 235 constReal(&dx)[]=par.dx; //Note:referencetoanarray 236 constint&maxIterations=par.maxIterations; 237 constint&debug=par.debug; 238 constint&intervalToCheckResidual=par.intervalToCheckResidual; 239 240 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 241 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 242 constintnd1a=dimension(0,0),nd1b=dimension(1,0); 243 constintnd2a=dimension(0,1),nd2b=dimension(1,1); 244 constintnd1=nd1b-nd1a+1; 245 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 246 247 constRealpi=M_PI; 248 249 intn; 250 Realh=dx[0]; //assumedx=dy 251 assert(dx[0]==dx[1]); 252 253 Realomega=2./(1.+sin(pi*h));//optimalomega 254 255 Realres0=getMaxResidual(u,f,par); 256 RealmaxRes=res0,maxResOld=maxRes,CR=1.; 257 258 constReal*f_p=f.getDataPointer(); 259 Real*u_p=u.getDataPointer(); 260 261 Realcpu1=getCPU(); 262 for(n=0;n<maxIterations;n++) 263 { 264 //omega-GSIteration 265 for(inti2=n2a+1;i2<=n2b-1;i2++) 266 for(inti1=n1a+1;i1<=n1b-1;i1++) 267 { 268 Realz=.25*(h*h*F(i1,i2)+U(i1+1,i2)+U(i1-1,i2)+U(i1,i2+1)+U(i1,i2-1)); 269 U(i1,i2)=U(i1,i2)+omega*(z-U(i1,i2)); 270 } 271 272 if((n%intervalToCheckResidual)==0||n==(maxIterations-1)) 273 { 274 //checkforconvergence 275 maxRes=getMaxResidual(u,f,par); 276 277 CR=pow((maxRes/maxResOld),1./intervalToCheckResidual); 278 maxResOld=maxRes; 279 if(false) 280 { 281 printf("GS:n=%6d,maxRes=%9.3e,CR=%7.4f\n",n,maxRes,CR); 282 } 283 284 if(maxRes<tol) 285 break; 286 } 287 288 } 289 Realcpu=getCPU()-cpu1; 290 291 constintnumIterations=n; 292 //printf("GS:numIterations=%d,nx=%d,ny=%d,cputime=%9.2e(s)\n",numIterations,nx,ny,cpu); 293 if(maxRes<tol) 294 { 295 //printf("GS:CONVERGENCE:maxRes=%8.2e<tol=%9.2e.\n",maxRes,tol); 296 } 297 else 298 printf("GS:ERROR:maxRes=%8.2e>tol=%9.2e:NOCONVERGENCE\n",maxRes,tol); 299 300 301 //---computeerrors-- 302 RealArrayerr(Rx,Ry); 303 RealmaxErr=getMaxError(u,err,par); 304 maxRes=getMaxResidual(u,f,par); 305 306 //Averageconvergencerate: 307 RealaveCR=pow((maxRes/res0),1./max(1,numIterations)); 308 //Asymptoticconvergencerate: 309 RealACR=omega-1.; 310 printf("GS:omega=%4.2fIts=%6dres=%8.2eerr=%8.2eCR=%7.5faveCR=%7.5fACR=%7.5fcpu=%7.1es cpu/it=%7.1es\n", 311 omega,numIterations,maxRes,maxErr,CR,aveCR,ACR,cpu,cpu/numIterations); 312 313 returnnumIterations; 314 } 315 316 //-------------------------------------------- 317 //Red-BlackGauss-Seideliteration 318 //-------------------------------------------- 319 //intredBlackIteration(RealArray&u,RealArray&f,Realxa,Realya,Realdx[],int maxIterations,Realtol,RealArray&uTrue) 320 intredBlackIteration(RealArray&u,RealArray&f,PoissonParameters&par) 321 { 322 323 constIntegerArray&gridIndexRange=par.gridIndexRange; 324 constIntegerArray&dimension=par.dimension; 325 constIntegerArray&boundaryCondition=par.boundaryCondition; 326 constRealArray&x=par.x; 327 constReal&tol=par.tol; 328 constRealArray&uTrue=par.uTrue; 329 constReal(&dx)[]=par.dx; //Note:referencetoanarray 330 constint&maxIterations=par.maxIterations; 331 constint&debug=par.debug; 332 constint&intervalToCheckResidual=par.intervalToCheckResidual; 333 334 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 335 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 336 constintnd1a=dimension(0,0),nd1b=dimension(1,0); 337 constintnd2a=dimension(0,1),nd2b=dimension(1,1); 338 constintnd1=nd1b-nd1a+1; 339 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 340 341 constRealpi=M_PI; 342 343 doubleArrayua[2]; 344 ua[0].redim(Rx,Ry);ua[0]=0.; 345 ua[1].redim(Rx,Ry);ua[1]=0.; 346 347 intcurrent=0; 348 ua[0]=u;//initialguess 349 ua[1]=u;//initialguess 350 351 intn; 352 Realh=dx[0]; //assumedx=dy 353 assert(dx[0]==dx[1]); 354 355 //thisistheoptimalomegaforANYordering(Owlbookp32) 356 constRealomega=2./(1.+sin(pi*h)); 357 358 Realres0=getMaxResidual(ua[current],f,par); 359 RealmaxRes=res0,maxResOld=res0; 360 RealCR=1.; 361 362 constReal*f_p=f.getDataPointer(); 363 364 Realcpu1=getCPU(); 365 for(n=0;n<maxIterations;n++) 366 { 367 constintnext=(current+1)%2; 368 doubleArray&u=ua[current]; 369 doubleArray&un=ua[next]; 370 371 Real*u_p=u.getDataPointer(); 372 Real*un_p=un.getDataPointer(); 373 374 //---omegaRed-Black-- 375 //Question:whatisthefastestwaytoloopoverredandblackpoints? 376 // (1)Useifstatement 377 // (2)Useloopswithstrideof2 378 //Note:loopsarefasterifLHSarrayisdifferentfromRHSarrays 379 for(inti2=n2a+1;i2<=n2b-1;i2++) 380 for(inti1=n1a+1;i1<=n1b-1;i1++) 381 { 382 if((i1+i2)%2==0)//redpoints 383 { 384 Realz=.25*(h*h*F(i1,i2)+U(i1+1,i2)+U(i1-1,i2)+U(i1,i2+1)+U(i1,i2-1)); 385 UN(i1,i2)=U(i1,i2)+omega*(z-U(i1,i2)); 386 } 387 else 388 { 389 UN(i1,i2)=U(i1,i2); 390 } 391 } 392 393 for(inti2=n2a+1;i2<=n2b-1;i2++) 394 for(inti1=n1a+1;i1<=n1b-1;i1++) 395 { 396 if((i1+i2)%2==1)//blackpoints 397 { 398 Realz=.25*(h*h*F(i1,i2)+UN(i1+1,i2)+UN(i1-1,i2)+UN(i1,i2+1)+UN(i1,i2-1)); 399 U(i1,i2)=UN(i1,i2)+omega*(z-UN(i1,i2)); 400 } 401 else 402 { 403 U(i1,i2)=UN(i1,i2); 404 } 405 } 406 407 if((n%intervalToCheckResidual)==0||n==(maxIterations-1)) 408 { 409 //checkforconvergence 410 maxRes=getMaxResidual(u,f,par); 411 CR=pow((maxRes/maxResOld),1./intervalToCheckResidual); 412 maxResOld=maxRes; 413 414 if(false) 415 printf("RB:n=%6d,maxRes=%9.3e,CR=%7.5f\n",n,maxRes,CR); 416 417 if(maxRes<tol) 418 break; 419 } 420 421 } 422 Realcpu=getCPU()-cpu1; 423 424 constintnumIterations=n; 425 //printf("numIterations=%d,nx=%d,ny=%d,cputime=%9.2e(s)\n",numIterations,nx,ny,cpu); 426 if(maxRes<tol) 427 { 428 //printf("CONVERGENCE:maxRes=%8.2e<tol=%9.2e.\n",maxRes,tol); 429 } 430 else 431 printf("Red-Black:ERROR:maxRes=%8.2e>tol=%9.2e:NOCONVERGENCE\n",maxRes,tol); 432 433 434 //---computeerrors-- 435 u=ua[current]; 436 RealArrayerr(Rx,Ry); 437 RealmaxErr=getMaxError(u,err,par); 438 maxRes=getMaxResidual(u,f,par); 439 440 //Averageconvergencerate: 441 RealaveCR=pow((maxRes/res0),1./max(1,numIterations)); 442 //Asymptoticconvergencerate: 443 RealACR=omega-1.; 444 printf("RB:omega=%4.2fIts=%6dres=%8.2eerr=%8.2eCR=%7.5faveCR=%7.5fACR=%7.5fcpu=%7.1es cpu/it=%7.1es\n", 445 omega,numIterations,maxRes,maxErr,CR,aveCR,ACR,cpu,cpu/numIterations); 446 447 returnnumIterations; 448 } 449 450 451 452 //-------------------------------------------- 453 //ConjugateGradientiteration 454 //-------------------------------------------- 455 intconjugateGradientIteration(RealArray&u,RealArray&f,PoissonParameters&par) 456 { 457 constIntegerArray&gridIndexRange=par.gridIndexRange; 458 constIntegerArray&dimension=par.dimension; 459 constIntegerArray&boundaryCondition=par.boundaryCondition; 460 constRealArray&x=par.x; 461 constReal&tol=par.tol; 462 constRealArray&uTrue=par.uTrue; 463 constReal(&dx)[]=par.dx; //Note:referencetoanarray 464 constint&maxIterations=par.maxIterations; 465 constint&debug=par.debug; 466 constint&intervalToCheckResidual=par.intervalToCheckResidual; 467 468 constintn1a=gridIndexRange(0,0),n1b=gridIndexRange(1,0); 469 constintn2a=gridIndexRange(0,1),n2b=gridIndexRange(1,1); 470 constintnd1a=dimension(0,0),nd1b=dimension(1,0); 471 constintnd2a=dimension(0,1),nd2b=dimension(1,1); 472 constintnd1=nd1b-nd1a+1; 473 474 constRealdxSq=dx[0]*dx[0]; 475 constRealdySq=dx[1]*dx[1]; 476 477 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 478 479 //Temporaryarrays 480 RealArrayz(Rx,Ry),r(Rx,Ry),p(Rx,Ry); 481 482 constReal*f_p=f.getDataPointer(); 483 484 Real*u_p=u.getDataPointer(); 485 Real*z_p=z.getDataPointer(); 486 Real*r_p=r.getDataPointer(); 487 Real*p_p=p.getDataPointer(); 488 #defineZ(i1,i2)z_p[(i1)+nd1*(i2)] 489 #defineR(i1,i2)r_p[(i1)+nd1*(i2)] 490 #defineP(i1,i2)p_p[(i1)+nd1*(i2)] 491 492 Realcpu1=getCPU(); 493 494 u=0.; //initialguess--***FIXMEfornon-zeroinitialguess*** 495 r=0; //initialresidualgoeshere 496 for(inti2=n2a+1;i2<=n2b-1;i2++) 497 for(inti1=n1a+1;i1<=n1b-1;i1++) 498 { 499 R(i1,i2)=F(i1,i2); //initialresidual 500 P(i1,i2)=R(i1,i2); //initialsearchdirection 501 } 502 503 Realalpha,beta,rNormSquared,rNormSquaredNew,pz; 504 505 //rNormSquared=r^Tr 506 rNormSquared=0.; 507 for(inti2=n2a+1;i2<=n2b-1;i2++) 508 for(inti1=n1a+1;i1<=n1b-1;i1++) 509 { 510 rNormSquared+=R(i1,i2)*R(i1,i2); 511 } 512 513 Realres0=sqrt(rNormSquared); 514 RealmaxRes=res0,maxResOld=res0; 515 RealCR=1.; 516 517 //printf("CG:res0=%9.2e,rNormSquared=%9.2e\n",res0,rNormSquared); 518 519 intn,nOld=-1; 520 for(n=0;n<maxIterations;n++) 521 { 522 523 //Note:Someloopshavebeencombinedforspeed 524 525 //z=Ap 526 //pz=p^Tz 527 //Note:A=-Delta 528 pz=0.; 529 for(inti2=n2a+1;i2<=n2b-1;i2++) 530 for(inti1=n1a+1;i1<=n1b-1;i1++) 531 { 532 Z(i1,i2)=-((P(i1+1,i2)-2.*P(i1,i2)+P(i1-1,i2))/dxSq 533 +(P(i1,i2+1)-2.*P(i1,i2)+P(i1,i2-1))/dySq); 534 pz+=P(i1,i2)*Z(i1,i2); 535 } 536 537 ////pz=p^Tz 538 //pz=0.; 539 //for(inti2=n2a+1;i2<=n2b-1;i2++) 540 //for(inti1=n1a+1;i1<=n1b-1;i1++) 541 //{ 542 // pz+=P(i1,i2)*Z(i1,i2); 543 //} 544 545 alpha=rNormSquared/pz; //steplength 546 547 //Mergingtheseintooneloopisfasterinserial 548 //u+=alpha*p 549 //r-=alpha*z 550 //rNormSquaredNew=r^Tr 551 rNormSquaredNew=0.; 552 for(inti2=n2a+1;i2<=n2b-1;i2++) 553 for(inti1=n1a+1;i1<=n1b-1;i1++) 554 { 555 U(i1,i2)+=alpha*P(i1,i2); //newsolution 556 R(i1,i2)-=alpha*Z(i1,i2); //residual 557 rNormSquaredNew+=R(i1,i2)*R(i1,i2); 558 } 559 560 ////r-=alpha*z 561 //rNormSquaredNew=0.; 562 //for(inti2=n2a+1;i2<=n2b-1;i2++) 563 //for(inti1=n1a+1;i1<=n1b-1;i1++) 564 //{ 565 // R(i1,i2)-=alpha*Z(i1,i2); //residual 566 // rNormSquaredNew+=R(i1,i2)*R(i1,i2); 567 //} 568 569 ////rNormSquaredNew=r^Tr *MERGEWITHPREVIOUSLOOP?? 570 //rNormSquaredNew=0.; 571 //for(inti2=n2a+1;i2<=n2b-1;i2++) 572 //for(inti1=n1a+1;i1<=n1b-1;i1++) 573 //{ 574 // rNormSquaredNew+=R(i1,i2)*R(i1,i2); 575 //} 576 577 beta=rNormSquaredNew/rNormSquared; //improvementthisstep 578 579 rNormSquared=rNormSquaredNew; 580 581 //p=r+beta*p 582 for(inti2=n2a+1;i2<=n2b-1;i2++) 583 for(inti1=n1a+1;i1<=n1b-1;i1++) 584 { 585 P(i1,i2)=R(i1,i2)+beta*P(i1,i2); //newsearchdirection 586 } 587 588 if((n%intervalToCheckResidual)==0||n==(maxIterations-1)) 589 { 590 //checkforconvergence ****WESHOULDREALLYUSEEXISTING2-normRESIDUAL**** 591 //Dothisfornowtobeconsistentwithotherschemes. 592 maxRes=getMaxResidual(u,f,par); 593 CR=pow((maxRes/maxResOld),1./max(1,n-nOld)); 594 maxResOld=maxRes; 595 nOld=n; 596 597 if(debug>0) 598 printf("CG:n=%3d:pz=%9.2e,alpha=%9.2e,beta=%9.2e,maxRes=%8.2e,CR=%7.5f\n",n,pz,alpha ,beta,maxRes,CR); 599 600 if(maxRes<tol) 601 break; 602 } 603 604 } 605 Realcpu=getCPU()-cpu1; 606 607 constintnumIterations=n; 608 //printf("numIterations=%d,nx=%d,ny=%d,cputime=%9.2e(s)\n",numIterations,nx,ny,cpu); 609 if(maxRes<tol) 610 { 611 //printf("CONVERGENCE:maxRes=%8.2e<tol=%9.2e.\n",maxRes,tol); 612 } 613 else 614 printf("CG:ERROR:maxRes=%8.2e>tol=%9.2e:NOCONVERGENCE\n",maxRes,tol); 615 616 617 //---computeerrors-- 618 RealArrayerr(Rx,Ry); 619 RealmaxErr=getMaxError(u,err,par); 620 maxRes=getMaxResidual(u,f,par); 621 622 //Averageconvergencerate: 623 RealaveCR=pow((maxRes/res0),1./max(1,numIterations)); 624 //Asymptoticconvergencerate: 625 constRealpi=M_PI; 626 RealACR=1.-pi*dx[0]; //**CHECKME** 627 printf("CG: Its=%6dres=%8.2eerr=%8.2eCR=%7.5faveCR=%7.5fACR=%7.5fcpu=%7.1escpu /it=%7.1es\n", 628 numIterations,maxRes,maxErr,CR,aveCR,ACR,cpu,cpu/numIterations); 629 630 returnnumIterations; 631 } 632 633 634 635 int 636 main(intargc,char*argv[]) 637 { 638 639 printf("Usage:poisson-nx=<i>-tol=<f>-maxIterations=<i>-debug=<i>\n" 640 " nx=numberofgridpointsinxandydirections\n" 641 " tol=convergencetolerance\n" 642 " maxIterations=maxnumberofiterations\n"); 643 644 constRealpi=M_PI;//4.*atan2(1.,1.); 645 646 //Parametersarestoredhere: 647 PoissonParameterspar; 648 649 //Makereferencestoparametersforclarity 650 IntegerArray&gridIndexRange=par.gridIndexRange; 651 IntegerArray&dimension=par.dimension; 652 IntegerArray&boundaryCondition=par.boundaryCondition; 653 RealArray&x=par.x; 654 Real&tol=par.tol; 655 RealArray&uTrue=par.uTrue; 656 Real(&dx)[]=par.dx; //Note:referencetoanarray 657 int&maxIterations=par.maxIterations; 658 int&debug=par.debug; 659 int&intervalToCheckResidual=par.intervalToCheckResidual; 660 661 intervalToCheckResidual=50;//checkresidualeverythismanyiterations 662 663 constintnumberOfDimensions=2; 664 Realxa=0.,xb=1.; //domainis[xa,xb]X[ya,yb] 665 Realya=0.,yb=1.; 666 667 debug=0; 668 maxIterations=1000; 669 tol=1.e-3; 670 intnx=100,ny=nx; 671 672 stringline; 673 for(inti=1;i<argc;i++) 674 { 675 line=argv[i]; 676 //printf("Input:argv[%d]=[%s]\n",i,line.c_str()); 677 if(parseCommand(line,"-nx=",nx)) 678 { 679 ny=nx; 680 } 681 elseif(parseCommand(line,"-debug=",debug)){} 682 elseif(parseCommand(line,"-maxIterations=",maxIterations)){} 683 elseif(parseCommand(line,"-tol=",tol)){} 684 685 } 686 687 printf("-----------------------------------------------------------------\n"); 688 printf("---------SolvethePoissonEquationintwodimensions----------\n"); 689 printf("-Delta(u)=f \n"); 690 printf(" DirichletBCs \n"); 691 printf(" nx=%d,ny=%d,maxIterations=%d,tol=%9.2e\n",nx,ny,maxIterations,tol); 692 printf("-----------------------------------------------------------------\n"); 693 694 constRealkx=1.,ky=1.; 695 constRealkxp=kx*pi; 696 constRealkyp=ky*pi; 697 698 //ThistruesolutionistooeasyforCGsinceuisamultipleoff: 699 //#defineUTRUE(x,y) sin(kxp*(x))*sin(kyp*(y)) 700 ////f=-Delta(u) 701 //#defineFORCE(x,y) (kxp*kxp+kyp*kyp)*UTRUE(x,y) 702 703 #defineUTRUE(x,y)(x)*(1.-(x))*(y)*(1.-(y)) 704 //f=-Delta(u) 705 #defineFORCE(x,y)2.*((x)*(1.-(x))+(y)*(1.-(y))) 706 707 708 constintnumGhost=0; 709 constintn1a=numGhost; 710 constintn1b=n1a+nx; 711 constintnd1a=n1a-numGhost; 712 constintnd1b=n1b+numGhost; 713 constintnd1=nd1b-nd1a+1; 714 715 constintn2a=numGhost; 716 constintn2b=n2a+ny; 717 constintnd2a=n2a-numGhost; 718 constintnd2b=n2b+numGhost; 719 constintnd2=nd2b-nd2a+1; 720 721 gridIndexRange.redim(2,numberOfDimensions); 722 dimension.redim(2,numberOfDimensions); 723 boundaryCondition.redim(2,numberOfDimensions); 724 725 gridIndexRange(0,0)=n1a;gridIndexRange(1,0)=n1b; 726 gridIndexRange(0,1)=n2a;gridIndexRange(1,1)=n2b; 727 728 dimension(0,0)=nd1a;dimension(1,0)=nd1b; 729 dimension(0,1)=nd2a;dimension(1,1)=nd2b; 730 731 boundaryCondition(0,0)=dirichlet;//left 732 boundaryCondition(1,0)=dirichlet;//right 733 734 boundaryCondition(0,1)=dirichlet;//bottom 735 boundaryCondition(1,1)=dirichlet;//top 736 737 //Gridpoints 738 RangeRx(nd1a,nd1b),Ry(nd2a,nd2b); 739 x.redim(Rx,Ry,2); 740 741 //Realdx[2]; 742 dx[0]=(xb-xa)/nx; 743 dx[1]=(yb-ya)/ny; 744 745 inti1,i2; 746 for(i2=nd2a;i2<=nd2b;i2++) 747 for(i1=nd1a;i1<=nd1b;i1++) 748 { 749 x(i1,i2,0)=xa+(i1-n1a)*dx[0]; 750 x(i1,i2,1)=ya+(i2-n2a)*dx[1]; 751 } 752 753 754 RealArrayf(Rx,Ry); 755 uTrue.redim(Rx,Ry); 756 757 RealArrayu(Rx,Ry); 758 759 Realxi,yi; 760 for(inti2=nd2a;i2<=nd2b;i2++) 761 for(inti1=nd1a;i1<=nd1b;i1++) 762 { 763 xi=x(i1,i2,0); 764 yi=x(i1,i2,1); 765 f(i1,i2)=FORCE(xi,yi); 766 uTrue(i1,i2)=UTRUE(xi,yi); 767 } 768 769 // =====JACOBI===== 770 u=0.;//initialguess 771 jacobiIteration(u,f,par); 772 773 // =====Gauss-Seidel===== 774 u=0.;//initialguess 775 gaussSeidelIteration(u,f,par); 776 777 // =====Red-BlackGauss-Seidel===== 778 u=0.;//initialguess 779 redBlackIteration(u,f,par); 780 781 //====ConjugateGradient========= 782 u=0.;//initialguess 783 conjugateGradientIteration(u,f,par); 784 785 return0; 786 }