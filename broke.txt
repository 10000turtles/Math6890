//=================================================================================== 2 // 3 // Solvetheheatequationinone-dimensionwithanIMPLICTMETHOD 4 // TRAPEZOIDALRULEINTIME 5 // 6 //=================================================================================== 7 8 #include"A++.h" 9 10 //Tridiagonalfactorandsolve: 11 #include"tridiagonal.h" 12 13 //definesometypes 14 typedefdoubleReal; 15 typedefdoubleSerialArrayRealArray; 16 typedefintSerialArrayIntegerArray; 17 18 #include<string> 19 usingstd::string; 20 usingstd::max; 21 22 //getCPU():Returnthecurrentwall-clocktimeinseconds 23 #include"getCPU.h" 24 25 //includecommandstoparsecommandlinearguments 26 #include"parseCommand.h" 27 28 29 //Functiontosaveavectortoamatlabfile. 30 #include"writeMatlabVector.h" 31 32 //Truesolutionoptions: 33 staticconstinttrueDD=1; 34 staticconstinttrueNN=2; 35 staticconstintpoly=3; 36 37 staticRealkappa=.1; 38 staticRealkx=3.; 39 staticRealkxPi=kx*M_PI; 40 staticRealkappaPiSq=kappa*kxPi*kxPi; 41 42 //TruesolutionfordirichletBC’s 43 #defineUTRUEDD(x,t)sin(kxPi*(x))*exp(-kappaPiSq*(t)) 44 #defineUTRUEDDx(x,t)kxPi*cos(kxPi*(x))*exp(-kappaPiSq*(t)) 45 #defineFORCEDD(x,t)(0.) 46 47 //TruesolutionforNeumannBC’s 48 #defineUTRUENN(x,t)cos(kxPi*(x))*exp(-kappaPiSq*(t)) 49 #defineUTRUENNx(x,t)-kxPi*sin(kxPi*(x))*exp(-kappaPiSq*(t)) 50 #defineFORCENN(x,t)(0.) 51 52 // polynomialmanufacturedsolution 53 staticconstRealb0=1.,b1=.5,b2=.25; 54 staticconstReala0=1.,a1=.3,a2=-.1; 55 #definePOLY(x,t)(b0+(x)*(b1+(x)*b2))*(a0+(t)*(a1+(t)*a2)) 56 #definePOLYx(x,t)(b1+2.*(x)*b2)*(a0+(t)*(a1+(t)*a2)) 57 #definePOLYT(x,t)(b0+(x)*(b1+(x)*b2))*(a1+2.*(t)*a2) 58 #definePOLYXx(x,t)(2.*b2)*(a0+(t)*(a1+(t)*a2)) 59 #definePOLYFORCE(x,t)(POLYT(x,t)-kappa*POLYXx(x,t)) 60 61 //-------------------------------------------------------------------------------------- 62 //Functiontoevaluatethetruesolution 63 // solutionOption (input):truesolutionoption 64 // t (input):time 65 // x (input):gridpoints 66 // I1 (input):evaluateattheseindexvalues 67 // uTrue (output):uTrue(I1)=truesolution 68 //-------------------------------------------------------------------------------------- 69 intgetTrue(intsolutionOption,Realt,RealArray&x,Index&I1,RealArray&uTrue) 70 { 71 if(solutionOption==trueDD) 72 uTrue(I1)=UTRUEDD(x(I1),t); 73 elseif(solutionOption==trueNN) 74 uTrue(I1)=UTRUENN(x(I1),t); 75 elseif(solutionOption==poly) 76 uTrue(I1)=POLY(x(I1),t); 77 else 78 { 79 printf("getTrue:unknownsolutonOption=%d\n",solutionOption); 80 abort(); 81 } 82 83 return0; 84 } 85 86 //-------------------------------------------------------------------------------------- 87 //Functiontoevaluatethex-derivativeofthetruesolution 88 //-------------------------------------------------------------------------------------- 89 intgetTruex(intsolutionOption,Realt,RealArray&x,Index&I1,RealArray&uTruex) 90 { 91 if(solutionOption==trueDD) 92 uTruex(I1)=UTRUEDDx(x(I1),t); 93 elseif(solutionOption==trueNN) 94 uTruex(I1)=UTRUENNx(x(I1),t); 95 elseif(solutionOption==poly) 96 uTruex(I1)=POLYx(x(I1),t); 97 else 98 { 99 printf("getTrue:unknownsolutonOption=%d\n",solutionOption); 100 abort(); 101 } 102 return0; 103 } 104 105 //-------------------------------------------------------------------------------------- 106 //FunctiontoevaluatethePDEforcing 107 //-------------------------------------------------------------------------------------- 108 intgetForce(intsolutionOption,Realt,RealArray&x,Index&I1,RealArray&force) 109 { 110 if(solutionOption==trueDD) 111 force(I1)=FORCEDD(x(I1),t); 112 elseif(solutionOption==trueNN) 113 force(I1)=FORCENN(x(I1),t); 114 elseif(solutionOption==poly) 115 force(I1)=POLYFORCE(x(I1),t); 116 else 117 { 118 printf("getTrue:unknownsolutonOption=%d\n",solutionOption); 119 abort(); 120 } 121 return0; 122 } 123 124 125 126 intmain(intargc,char*argv[]) 127 { 128 129 printf("Usage:heat1dImp-Nx=<i>-tFinal=<f>-sol=[true|poly]-bc1=[d|n]-bc2=[d|n]-debug=<i>matlabFileName=<s>\n"); 130 131 constRealpi=M_PI; 132 133 constintnumberOfDimensions=1; 134 intNx=10; 135 136 Realxa=0.,xb=1.; 137 RealtFinal=1.; 138 139 //setupboundaryconditionarray 140 constintdirichlet=1,neumann=2; 141 IntegerArrayboundaryCondition(2,numberOfDimensions); 142 boundaryCondition(0,0)=dirichlet; //left 143 boundaryCondition(1,0)=dirichlet; //right 144 145 intdebug=0; 146 stringmatlabFileName="heat1d.m"; 147 148 constinttrueSolution=0,polynomialSolution=1; 149 intsol=trueSolution; 150 stringsolName="true"; 151 152 stringline; 153 for(inti=1;i<argc;i++) 154 { 155 line=argv[i]; 156 //printf("Input:argv[%d]=[%s]\n",i,line.c_str()); 157 158 if(parseCommand(line,"-Nx=",Nx)){} 159 elseif(parseCommand(line,"-debug=",debug)){} 160 elseif(parseCommand(line,"-tFinal=",tFinal)){} 161 elseif(parseCommand(line,"-matlabFileName=",matlabFileName)){} 162 elseif(line.substr(0,4)=="-sol") 163 { 164 solName=line.substr(5); //solName=character5toend 165 if(solName=="true") 166 sol=trueSolution; 167 elseif(solName=="poly") 168 sol=polynomialSolution; 169 else 170 { 171 printf("ERROR:Unknown-sol=[%s]\n",solName.c_str()); 172 abort(); 173 } 174 printf("settingsolName=[%s]\n",solName.c_str()); 175 } 176 elseif(line.substr(0,5)=="-bc1="|| 177 line.substr(0,5)=="-bc2=" ) 178 { 179 intside=line.substr(0,5)=="-bc1="?0:1; 180 stringbcName=line.substr(5,1); 181 if(bcName=="d") 182 { 183 boundaryCondition(side,0)=dirichlet; 184 printf("SETTINGboundaryCondition(%d,0)=dirichlet\n",side); 185 } 186 elseif(bcName=="n") 187 { 188 boundaryCondition(side,0)=neumann; 189 printf("SETTINGboundaryCondition(%d,0)=neumann\n",side); 190 } 191 else 192 { 193 printf("Uknownbc:line=[%s]\n",line.c_str()); 194 } 195 } 196 } 197 stringbcName[2]; 198 for(intside=0;side<=1;side++) 199 { 200 if(boundaryCondition(side,0)==dirichlet) 201 bcName[side]="D"; 202 else 203 bcName[side]="N"; 204 } 205 206 //setthesolutionOption: 207 intsolutionOption=trueDD; 208 if(boundaryCondition(0,0)==dirichlet&&boundaryCondition(1,0)==dirichlet) 209 { 210 solutionOption=sol==trueSolution?trueDD:poly; 211 } 212 elseif(boundaryCondition(0,0)==neumann&&boundaryCondition(1,0)==neumann) 213 { 214 solutionOption=sol==trueSolution?trueNN:poly; 215 } 216 else 217 { 218 printf("Unexpectedboundaryconditionswiththetruesolution--FINISHME\n"); 219 abort(); 220 } 221 conststringsolutionName=solName+bcName[0]+bcName[1]; 222 223 //=============Gridandindexing============== 224 // xa xb 225 // G---X---+---+---+---+--...---+---X---G 226 // 0 1 2 Nx 227 // n1a n1b 228 // nd1a nd1b 229 //Cindex: 0 1 2 3... 230 231 232 Realdx=(xb-xa)/Nx; 233 constintnumGhost=1; 234 constintn1a=0; 235 constintn1b=Nx; 236 constintnd1a=n1a-numGhost; 237 constintnd1b=n1b+numGhost; 238 239 intnd1=nd1b-nd1a+1;//totalnumberofgridpoints; 240 241 //Gridpoints: 242 RangeRx(nd1a,nd1b); 243 RealArrayx(Rx); 244 245 for(inti=nd1a;i<=nd1b;i++) 246 x(i)=xa+(i-n1a)*dx; 247 248 if(debug>1) 249 { 250 for(inti=nd1a;i<=nd1b;i++) 251 printf("x(%2d)=%12.4e\n",i,x(i)); 252 } 253 254 RealArrayu[2]; //twoarrayswillbeusedforcurrentandnewtimes 255 u[0].redim(Rx); 256 u[1].redim(Rx); 257 258 //Macrostodefinefortranlikearrays 259 #defineuc(i)u[cur](i) 260 #defineun(i)u[next](i) 261 262 //initialconditions 263 Realt=0.; 264 intcur=0;//"current"solution,indexintou_p[] 265 IndexI1=Range(nd1a,nd1b); 266 getTrue(solutionOption,t,x,I1,u[cur]); 267 268 if(debug>0) 269 { 270 printf("Afterinitialconditions\nu=["); 271 for(inti=nd1a;i<=nd1b;i++) 272 printf("%10.4e,",uc(i)); 273 printf("]\n"); 274 } 275 276 277 //Choosetime-step 278 constRealdx2=dx*dx; 279 Realdt=dx; //dt,adjustedbelow 280 constintnumSteps=ceil(tFinal/dt); 281 dt=tFinal/numSteps; //adjustdttoreachthefinaltime 282 283 //---Tridiagonalmatrix--- 284 //Ax(0:2,i1):holdsthe3diagonals 285 // [Ax(1,0)Ax(2,0) ] 286 // [Ax(0,1)Ax(1,1)Ax(2,1) ] 287 // [ Ax(0,2)Ax(1,2)Ax(2,2) ] 288 // 289 RangeIx(n1a,n1b);//interiorandboundarypoints 290 RealArrayAx(Range(3),Ix); 291 RealArrayrhsx(Ix); 292 Real*rhsx_p=rhsx.getDataPointer(); 293 #defineRHS(i)rhsx_p[i-n1a] 294 295 //----Fillthetridiagonalmatrix--- 296 constRealrx=kappa*dt/dx2; 297 for(inti1=n1a+1;i1<=n1b-1;i1++) 298 { 299 Ax(0,i1)=-.5*rx; //lowerdiagonal 300 Ax(1,i1)=1.+rx; //diagonal 301 Ax(2,i1)=-.5*rx; //upperdiagonal 302 } 303 for(intside=0;side<=1;side++) 304 { 305 inti1=side==0?n1a:n1b; 306 if(boundaryCondition(side,0)==dirichlet) 307 {//DirichletBC 308 Ax(0,i1)=0.;Ax(1,i1)=1.;Ax(2,i1)=0.; 309 } 310 else 311 {//NeumannBC 312 //CombineNeumannBCwithinteriorequationontheboundary 313 //toeliminatetheghostpoint 314 intis=1-2*side; 315 Ax(1-is,i1)=0.;Ax(1,i1)=1.+rx;Ax(1+is,i1)=-rx;//NeumannBC 316 317 } 318 } 319 320 //FactormatrixONCE 321 factorTridiagonalMatrix(Ax); 322 323 printf("---------ImplicitSolveoftheHeatEquationin1D,solutionOption=%d,solutionName=%s-----------\n", 324 solutionOption,solutionName.c_str()); 325 printf(" numSteps=%d,Nx=%d,debug=%d,kappa=%g,tFinal=%g,\n" 326 " boundaryCondition(0,0)=%s,boundaryCondition(1,0)=%s\n", 327 numSteps,Nx,debug,kappa,tFinal,bcName[0].c_str(),bcName[1].c_str()); 328 329 RealArrayuTrue(Rx);//storeuTruehere 330 RealArrayfn[2]; //saveforcingattwotimelevels 331 fn[0].redim(Rx); 332 fn[1].redim(Rx); 333 334 getForce(solutionOption,t,x,I1,fn[0]); 335 336 //----------TIME-STEPPINGLOOP-------- 337 Realcpu0=getCPU(); 338 for(intn=0;n<numSteps;n++) 339 { 340 t=n*dt; //currenttime 341 342 intcur=n%2; //currenttimelevel 343 intnext=(n+1)%2; //nexttimelevel 344 345 //---AssigntheRHS--- 346 347 //getforcingatt+dt 348 getForce(solutionOption,t+dt,x,I1,fn[next]); 349 350 Real*uc_p=u[cur].getDataPointer(); 351 #defineUC(i)uc_p[i-nd1a] 352 Real*un_p=u[next].getDataPointer(); 353 #defineUN(i)un_p[i-nd1a] 354 355 Real*fc_p=fn[cur].getDataPointer(); 356 #defineFC(i)fc_p[i-nd1a] 357 Real*fn_p=fn[next].getDataPointer(); 358 #defineFN(i)fn_p[i-nd1a] 359 360 361 for(inti=n1a;i<=n1b;i++) 362 { 363 RHS(i)=UC(i)+(.5*rx)*(UC(i+1)-2.*UC(i)+UC(i-1))+(.5*dt)*(FC(i)+FN(i)); 364 } 365 366 //----RHSforboundaryconditions--- 367 for(intside=0;side<=1;side++) 368 { 369 constinti1=side==0?n1a:n1b; 370 constintis=1-2*side; 371 IndexIb=Range(i1,i1); 372 373 if(boundaryCondition(side,0)==dirichlet) 374 { 375 getTrue(solutionOption,t+dt,x,Ib,uTrue); 376 RHS(i1)=uTrue(i1); 377 } 378 else 379 { 380 //TheNeumannBC, (U(i1+1)-U(i1-1))/(2*dx)=g, 381 //iscombinewiththeequationonthboundarytoeliminatethe 382 //ghostpointvalue.Thisresultsinanadjustmenttotherhs.(seeclassnotes) 383 getTruex(solutionOption,t+dt,x,Ib,uTrue);//storeuxinuTrue(i1) 384 RHS(i1)=RHS(i1)-(is*dx*rx)*uTrue(i1); 385 } 386 } 387 388 solveTridiagonal(Ax,rhsx); 389 390 //fillinthesolution 391 for(inti=n1a;i<=n1b;i++) 392 UN(i)=RHS(i); 393 394 //Fillghostpointvalues 395 for(intside=0;side<=1;side++) 396 { 397 constinti1=side==0?n1a:n1b; 398 constintis=1-2*side; 399 IndexIb=Range(i1,i1); 400 if(boundaryCondition(side,0)==dirichlet) 401 { 402 //Useextrapolation: 403 UN(i1-is)=3.*UN(i1)-3.*UN(i1+is)+UN(i1+2*is); 404 } 405 else 406 { 407 //Neumann: (U(i1+1)-U(i1-1))/(2*dx)=g 408 //getTruex(solutionOption,t+dt,x,Ib,uTrue );//noneedtore-evaluate 409 UN(i1-is)=UN(i1+is)-2.*is*dx*uTrue(i1); 410 } 411 } 412 413 if(debug>1) 414 { 415 printf("step%d:AfterupdateinteriorandrealBCs\nu=[",n+1); 416 for(inti=nd1a;i<=nd1b;i++) 417 printf("%12.4e,",un(i)); 418 printf("]\n"); 419 } 420 421 if(debug>0) 422 { 423 //computetheerror 424 RealmaxErr=0.; 425 RealmaxNorm=0.; 426 427 getTrue(solutionOption,t+dt,x,I1,uTrue); 428 429 for(inti=nd1a;i<=nd1b;i++) 430 { 431 Realerr=fabs(un(i)-uTrue(i)); 432 //Realerr=fabs(un(i)-uTrue(x(i),t+dt)); 433 maxErr=max(maxErr,err); 434 maxNorm=max(maxNorm,abs(un(i))); 435 } 436 maxErr/=maxNorm; 437 printf("step=%d,t=%9.3e,maxNorm=%9.2e,maxRelErr=%9.2e\n",n+1,t+dt,maxNorm,maxErr); 438 439 } 440 441 } 442 443 RealcpuTimeStep=getCPU()-cpu0; 444 445 //checktheerror: 446 t+=dt;//tFinal; 447 if(fabs(t-tFinal)>1e-3*dt/tFinal) 448 { 449 printf("ERROR:AFTERTIME_STEPPING:t=%16.8eISNOTEQUALtotFinal=%16.8e\n",t,tFinal); 450 } 451 452 RealArrayerr(Rx); 453 454 cur=numSteps%2; 455 RealmaxErr=0.; 456 RealmaxNorm=0.; 457 458 getTrue(solutionOption,t,x,I1,uTrue); 459 460 //Computefinalerror:donotincludeunusedghostpointonDirichletboundaries 461 constintn1ae=boundaryCondition(0,0)==dirichlet?n1a:n1a-1; 462 constintn1be=boundaryCondition(1,0)==dirichlet?n1b:n1b+1; 463 for(inti=n1ae;i<=n1be;i++) 464 { 465 err(i)=uc(i)-uTrue(i); 466 maxErr=max(maxErr,abs(err(i))); 467 maxNorm=max(maxNorm,abs(uc(i))); 468 } 469 maxErr/=maxNorm; 470 471 472 printf("numSteps=%4d,Nx=%3d,maxNorm=%9.2e,maxRelErr=%9.2e,cpu=%9.2e(s)\n", 473 numSteps,Nx,maxNorm,maxErr,cpuTimeStep); 474 475 476 //---Writeamatlabfileforplottinginmatlab-- 477 FILE*matlabFile=fopen(matlabFileName.c_str(),"w"); 478 fprintf(matlabFile,"%%Filewrittenbyheat1dImp.C\n"); 479 fprintf(matlabFile,"xa=%g;xb=%g;kappa=%g;t=%g;maxErr=%10.3e;cpuTimeStep=%10.3e;\n",xa,xb, kappa,tFinal,maxErr,cpuTimeStep); 480 fprintf(matlabFile,"Nx=%d;dx=%14.6e;numGhost=%d;n1a=%d;n1b=%d;nd1a=%d;nd1b=%d;\n",Nx,dx, numGhost,n1a,n1b,nd1a,nd1b); 481 fprintf(matlabFile,"solutionName=\’%s\’;\n",solutionName.c_str()); 482 483 writeMatlabVector(matlabFile,x, "x",nd1a,nd1b); 484 writeMatlabVector(matlabFile,u[cur],"u",nd1a,nd1b); 485 writeMatlabVector(matlabFile,err, "err",nd1a,nd1b); 486 487 fclose(matlabFile); 488 printf("Wrotefile[%s]\n",matlabFileName.c_str()); 489 490 return0; 491 }